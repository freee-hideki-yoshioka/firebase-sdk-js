{"version":3,"file":"index.js","sources":["webpack:///webpack/bootstrap","webpack:///./src/index.ts","webpack:///./src/sdk/api/freee-api-client.ts","webpack:///./src/sdk/auth/freee-firebase-auth-client.ts","webpack:///./src/sdk/freee-server-sdk.ts","webpack:///./src/sdk/services/config-manager.ts","webpack:///./src/sdk/services/freee-cryptor.ts","webpack:///./src/sdk/services/token-manager.ts","webpack:///external \"axios\"","webpack:///external \"crypto\"","webpack:///external \"date-fns\"","webpack:///external \"firebase-admin\"","webpack:///external \"firebase-functions\"","webpack:///external \"form-data\"","webpack:///external \"simple-oauth2\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","import FreeeServerSDK from './sdk/freee-server-sdk'\n\nexport { FreeeServerSDK }\n","import { AxiosPromise, AxiosStatic } from 'axios'\nimport { ParamJSON } from '../const/types'\nimport { TokenManager } from '../services/token-manager'\nimport * as FormData from 'form-data';\n\nexport class FreeeAPIClient {\n  private tokenManager: TokenManager\n  private axios: AxiosStatic\n\n  constructor(tokenManager: TokenManager, axios: AxiosStatic) {\n    this.tokenManager = tokenManager\n    this.axios = axios\n  }\n\n  /**\n   * Call freee api by GET\n   */\n  get<T = any>(\n    url: string,\n    params: ParamJSON,\n    userId: string\n  ): AxiosPromise<T> {\n    return this.tokenManager.get(userId).then(accessToken => {\n      const headers = {\n        Authorization: `Bearer ${accessToken}`,\n        'X-Api-Version': '2020-06-15',\n        'Content-Type': 'application/json'\n      }\n      return this.axios.get(url, {\n        params: params,\n        headers: headers\n      })\n    })\n  }\n\n  /**\n   * Call freee api by POST\n   */\n  post<T = any>(url: string, data: ParamJSON, userId: string): AxiosPromise<T> {\n    return this.tokenManager.get(userId).then(accessToken => {\n      let sendData = data\n      let sendHeaders: { [key: string]: any }  = {}\n      let sendContentType = 'application/json'\n\n      const isMultipartRequest = url === 'api/1/receipts'\n      if (isMultipartRequest) {\n        const formData = new FormData()\n        Object.keys(data).forEach(key => {\n          formData.append(key, data[key])\n        })\n        sendData = formData\n        sendHeaders = formData.getHeaders()\n        sendContentType = 'multipart/form-data'\n      }\n\n      sendHeaders['Authorization'] = `Bearer ${accessToken}`\n      sendHeaders['X-Api-Version'] = '2020-06-15'\n      sendHeaders['Content-Type'] = sendContentType\n\n      return this.axios.post(url, sendData, {\n        maxContentLength: 112197632,\n        headers: sendHeaders\n      })\n    })\n  }\n\n  /**\n   * Call freee api by PUT\n   */\n  put<T = any>(url: string, data: ParamJSON, userId: string): AxiosPromise<T> {\n    return this.tokenManager.get(userId).then(accessToken => {\n      const headers = {\n        Authorization: `Bearer ${accessToken}`,\n        'X-Api-Version': '2020-06-15',\n        'Content-Type': 'application/json'\n      }\n      return this.axios.put(url, data, {\n        headers: headers\n      })\n    })\n  }\n\n  /**\n   * Call freee api by GET\n   */\n  delete(url: string, data: ParamJSON, userId: string): AxiosPromise {\n    return this.tokenManager.get(userId).then(accessToken => {\n      const headers = {\n        Authorization: `Bearer ${accessToken}`,\n        'X-Api-Version': '2020-06-15',\n        'Content-Type': 'application/json'\n      }\n      return this.axios.delete(url, {\n        data: data,\n        headers: headers\n      })\n    })\n  }\n}\n","import { AxiosStatic } from 'axios'\nimport * as admin from 'firebase-admin'\nimport { Response } from 'firebase-functions'\nimport { FreeeToken, SDKConfig } from '../const/types'\nimport { ConfigKeys, ConfigManager } from '../services/config-manager'\nimport { TokenManager } from '../services/token-manager'\n\nexport class FreeeFirebaseAuthClient {\n  private admin: admin.app.App\n  private oauth2: any // Can not use typescript version due to mismatch with freee oauth\n  private axios: AxiosStatic\n  private tokenManager: TokenManager\n  private clientId: string\n  private clientSecret: string\n  private redirectPath: string\n  private callbackPath: string\n  private companiesPath: string\n  private homePath: string\n  private appHost: string\n  private authHost: string\n  // @ts-ignore  FIXME: tslint でエラーになる。不要なら削除する\n  private apiKey?: string\n\n  constructor(\n    admin: admin.app.App,\n    oauth2: any,\n    axios: AxiosStatic,\n    tokenManager: TokenManager,\n    config: SDKConfig\n  ) {\n    this.admin = admin\n    this.oauth2 = oauth2\n    this.axios = axios\n    this.tokenManager = tokenManager\n    // path setting\n    const freeeConfigs = config.freee!\n    const functionsConfigs = ConfigManager.getFunctionsConfigs()\n    this.clientId = functionsConfigs.freee.client_id\n    this.clientSecret = functionsConfigs.freee.client_secret\n    this.redirectPath = ConfigManager.get(freeeConfigs, ConfigKeys.redirectPath)\n    this.callbackPath = ConfigManager.get(freeeConfigs, ConfigKeys.callbackPath)\n    this.companiesPath = ConfigManager.get(\n      freeeConfigs,\n      ConfigKeys.companiesPath\n    )\n    this.homePath = ConfigManager.get(freeeConfigs, ConfigKeys.homePath)\n    this.appHost = ConfigManager.get(freeeConfigs, ConfigKeys.appHost)\n    this.authHost = ConfigManager.get(freeeConfigs, ConfigKeys.authHost)\n    this.apiKey = config.firebase && config.firebase.apiKey!\n  }\n\n  /**\n   * Redirect screen to authorize\n   */\n  redirect(res: Response): void {\n    const redirectUri = this.oauth2.authorizationCode.authorizeURL({\n      redirect_uri: `${this.authHost}${this.getCallbackPath()}`\n    })\n    res.redirect(redirectUri)\n  }\n\n  /**\n   * Get token, save it to firebase and login firebase\n   */\n  async callback(code: string, res: Response): Promise<void> {\n    try {\n      const result = await this.oauth2.authorizationCode\n        .getToken({\n          client_id: this.clientId,\n          client_secret: this.clientSecret,\n          code: code,\n          redirect_uri: `${this.authHost}${this.getCallbackPath()}`\n        })\n\n      const freeeToken = {\n        accessToken: result.access_token,\n        refreshToken: result.refresh_token,\n        expiresIn: result.expires_in,\n        createdAt: result.created_at\n      }\n\n      // get freee user\n      const response = await this.getFreeeUser(freeeToken.accessToken)\n\n      const id = response.data.user.id\n      const email = response.data.user.email\n      // consider null value of displayName\n      const displayName = response.data.user.display_name\n        ? response.data.user.display_name\n        : ''\n      // Create a Firebase Account and get the custom Auth Token.\n      const firebaseToken = await this.createFirebaseAccount(\n        id,\n        email,\n        displayName,\n        freeeToken\n      )\n      // redirect to home path with token info\n      res.redirect(`${this.appHost}${this.homePath}?token=${firebaseToken}`)\n    } catch (error) {\n      console.error('Some error occured on login process:', error)\n      res.send(this.signInRefusedTemplate())\n    }\n  }\n\n  /**\n   * path for redirect on freee authorization\n   */\n  getRedirectPath(): string {\n    return this.redirectPath\n  }\n\n  /**\n   * path for callback on freee authorization\n   */\n  getCallbackPath(): string {\n    return this.callbackPath\n  }\n\n  /**\n   * path for callback on freee authorization\n   */\n  getCompaniesPath(): string {\n    return this.companiesPath\n  }\n\n  /**\n   * Create crypto key to bucket for it by specified date\n   */\n  async createCryptoKey(date: Date): Promise<void> {\n    await this.tokenManager.createCryptoKey(date)\n  }\n\n  private getFreeeUser(accessToken: string) {\n    return this.axios.get('/api/1/users/me?companies=true', {\n      headers: { Authorization: `Bearer ${accessToken}` }\n    })\n  }\n\n  /**\n   * create firebase account and token\n   */\n  private async createFirebaseAccount(\n    id: number,\n    email: string,\n    displayName: string,\n    freeeToken: FreeeToken\n  ): Promise<string> {\n    const uid = id.toString()\n\n    await this.tokenManager.save(uid, email, freeeToken)\n\n    // Create or update the user account.\n    await this.admin\n      .auth()\n      .updateUser(uid, {\n        email: email,\n        displayName: displayName\n      })\n      .catch(async error => {\n        if (error.code === 'auth/user-not-found') {\n          return await this.admin.auth().createUser({\n            uid: uid,\n            email: email,\n            displayName: displayName\n          })\n        }\n        throw error\n      })\n\n    return await this.admin.auth().createCustomToken(uid)\n  }\n\n  /**\n   * Script for redirection when user refuse sign-up\n   */\n  private signInRefusedTemplate(): string {\n    return `\n      <script>\n        window.location.href = '${this.appHost}'\n      </script>`\n  }\n}\n","/**\n * @fileoverview sdk for freee api in server side\n */\nimport axios from 'axios'\nimport * as admin from 'firebase-admin'\nimport { FreeeAPIClient } from './api/freee-api-client'\nimport { FreeeFirebaseAuthClient } from './auth/freee-firebase-auth-client'\nimport { SDKConfig, SDKFreeeConfig } from './const/types'\nimport { ConfigKeys, ConfigManager } from './services/config-manager'\nimport FreeeCryptor from './services/freee-cryptor'\nimport { TokenManager } from './services/token-manager'\n\nclass FreeeServerSDK {\n  private admin: admin.app.App\n  private apiClient: FreeeAPIClient\n  private firebaseAuthClient: FreeeFirebaseAuthClient\n\n  constructor(\n    config: SDKConfig,\n    serviceAccount: { [key: string]: string } | null\n  ) {\n    const freeeConfigs = config.freee!\n    // Set up firebase admin\n    if (serviceAccount) {\n      // for local\n      this.admin = admin.initializeApp({\n        credential: admin.credential.cert(serviceAccount),\n        databaseURL: `https://${serviceAccount.project_id}.firebaseio.com`,\n        storageBucket: `${serviceAccount.project_id}.appspot.com`\n      })\n    } else {\n      // Firebase setup by ADC\n      this.admin = admin.initializeApp()\n    }\n\n    // Set up cryptor for freee token\n    const cryptoKeyBucket = ConfigManager.get(\n      config.firebase!,\n      ConfigKeys.cryptoKeyBucket\n    )\n    const cryptor = cryptoKeyBucket\n      ? new FreeeCryptor(this.admin.storage().bucket(cryptoKeyBucket))\n      : null\n\n    // Set up oauth2 client\n    const oauth2 = require('simple-oauth2').create(\n      this.getCredentials(freeeConfigs)\n    )\n    const tokenManager = new TokenManager(this.admin, oauth2, cryptor)\n\n    axios.defaults.baseURL = ConfigManager.get(freeeConfigs, ConfigKeys.apiHost)\n\n    this.apiClient = new FreeeAPIClient(tokenManager, axios)\n    this.firebaseAuthClient = new FreeeFirebaseAuthClient(\n      this.admin,\n      oauth2,\n      axios,\n      tokenManager,\n      config\n    )\n  }\n\n  /**\n   * get firebase admin instance\n   */\n  firebaseApp(): admin.app.App {\n    return this.admin\n  }\n\n  /**\n   * get firebase admin instance\n   */\n  api(): FreeeAPIClient {\n    return this.apiClient\n  }\n\n  /**\n   * get firebase admin instance\n   */\n  auth(): FreeeFirebaseAuthClient {\n    return this.firebaseAuthClient\n  }\n\n  private getCredentials(freeeConfigs: SDKFreeeConfig) {\n    const freee = ConfigManager.getFunctionsConfigs().freee\n\n    const credentials = {\n      client: {\n        id: freee.client_id,\n        secret: freee.client_secret\n      },\n      auth: {\n        tokenHost: ConfigManager.get(freeeConfigs, ConfigKeys.tokenHost),\n        authorizePath: ConfigManager.get(\n          freeeConfigs,\n          ConfigKeys.authorizePath\n        ),\n        tokenPath: ConfigManager.get(freeeConfigs, ConfigKeys.tokenPath)\n      }\n    }\n\n    return credentials\n  }\n}\n\nexport default FreeeServerSDK\n","import * as functions from 'firebase-functions'\nimport { SUPPORTED_REGIONS } from 'firebase-functions'\nimport { SDKBaseConfig } from '../const/types'\n\nconst adminConfig = JSON.parse(process.env.FIREBASE_CONFIG!)\nconst projectId = adminConfig.projectId\nconst region =\n  functions.config().env && functions.config().env.region\n    ? functions.config().env.region\n    : 'asia-northeast1'\n\nexport enum ConfigKeys {\n  apiHost = 'apiHost',\n  appHost = 'appHost',\n  authHost = 'authHost',\n  redirectPath = 'redirectPath',\n  callbackPath = 'callbackPath',\n  companiesPath = 'companiesPath',\n  homePath = 'homePath',\n  tokenHost = 'tokenHost',\n  authorizePath = 'authorizePath',\n  tokenPath = 'tokenPath',\n  cryptoKeyBucket = 'cryptoKeyBucket'\n}\n\ninterface FirebaseFunctionsConfigs {\n  env: {\n    mode: 'production' | string\n    region: typeof SUPPORTED_REGIONS\n  }\n  freee: {\n    client_id: string\n    client_secret: string\n  }\n}\n\ninterface DefaultConfig {\n  key: ConfigKeys\n  default: string\n  production?: string\n}\n\ninterface DefaltConfigs {\n  freee: DefaultConfig[]\n  firebase: DefaultConfig[]\n}\n\n/**\n * Default value definitions for {@link SDKFreeeConfig}\n *\n * @see {SDKFreeeConfig}\n */\nconst DEFAULT_CONFIGS: DefaltConfigs = {\n  freee: [\n    {\n      key: ConfigKeys.apiHost,\n      default: 'https://api.freee.co.jp',\n      production: 'https://api.freee.co.jp'\n    },\n    {\n      key: ConfigKeys.appHost,\n      default: 'http://localhost:5000',\n      production: `https://${projectId}.web.app`\n    },\n    {\n      key: ConfigKeys.authHost,\n      default: `http://localhost:5001/${projectId}/${region}/api/auth`,\n      production: `https://${region}-${projectId}.cloudfunctions.net/api/auth`\n    },\n    {\n      key: ConfigKeys.redirectPath,\n      default: '/redirect'\n    },\n    {\n      key: ConfigKeys.callbackPath,\n      default: '/callback'\n    },\n    {\n      key: ConfigKeys.companiesPath,\n      default: '/companies'\n    },\n    {\n      key: ConfigKeys.homePath,\n      default: '/'\n    },\n    {\n      key: ConfigKeys.tokenHost,\n      default: 'https://accounts.secure.freee.co.jp',\n      production: 'https://accounts.secure.freee.co.jp'\n    },\n    {\n      key: ConfigKeys.authorizePath,\n      default: '/public_api/authorize'\n    },\n    {\n      key: ConfigKeys.tokenPath,\n      default: '/public_api/token'\n    }\n  ],\n  firebase: [\n    {\n      key: ConfigKeys.cryptoKeyBucket,\n      default: `${projectId}.appspot.com`\n    }\n  ]\n}\n\nexport class ConfigManager {\n  static get(configs: SDKBaseConfig | null, key: ConfigKeys) {\n    if (configs && this.hasKey(configs, key)) {\n      return configs[key]!\n    }\n\n    return this.getDefaultValue(key)\n  }\n\n  static getFunctionsConfigs(): FirebaseFunctionsConfigs {\n    return functions.config() as FirebaseFunctionsConfigs\n  }\n\n  private static getDefaultValue(key: ConfigKeys) {\n    const defaultConfigs = ([] as DefaultConfig[])\n      .concat(DEFAULT_CONFIGS.freee)\n      .concat(DEFAULT_CONFIGS.firebase)\n    const config = defaultConfigs.find(config => config.key === key)!\n    return this.isProduction() && config.production\n      ? config.production\n      : config.default\n  }\n\n  private static isProduction() {\n    const configs = this.getFunctionsConfigs()\n    return configs.env && configs.env.mode === 'production'\n  }\n\n  private static hasKey(configs: SDKBaseConfig, key: ConfigKeys) {\n    return Object.keys(configs).find(configKey => configKey === key)\n  }\n}\n","import { Bucket } from '@google-cloud/storage'\nimport { Cipher, Decipher } from 'crypto'\nimport { format } from 'date-fns'\nimport { FreeeToken } from '../const/types'\n\nconst crypto = require('crypto')\n\nconst ALGORITHM = 'aes-256-cbc'\nconst OUT = 'base64'\nconst IN = 'utf8'\nconst IV_LENGTH = 16\n\nexport interface FreeeTokenWithCryptInfo extends FreeeToken {\n  keyFileName: string\n  algorithm: string\n  iv: string\n}\n\nclass FreeeCryptor {\n  private bucket: Bucket\n  private keyCache: { [key: string]: Buffer }\n\n  constructor(bucket: Bucket) {\n    this.bucket = bucket\n    this.keyCache = {}\n  }\n\n  /**\n   * Create crypto key to bucket for it by specified date\n   */\n  async createCryptoKey(date: Date): Promise<void> {\n    const keyFileName = format(date, 'yyyyMM')\n    return this.create(keyFileName)\n  }\n\n  /**\n   * Encrypt freee token\n   *\n   * @param {Object} token\n   * @param {string} token.accessToken\n   * @param {string} token.refreshToken\n   *\n   * @return {Promise<Object>} - encrypted freee token object\n   */\n  async encrypt(token: FreeeToken): Promise<FreeeTokenWithCryptInfo> {\n    const { accessToken, refreshToken } = token\n    const keyFileName = format(new Date(), 'yyyyMM')\n    const key = await this.getKey(keyFileName)\n    const iv = crypto.randomBytes(IV_LENGTH)\n\n    console.log(\"FreeeCryptor_encrypt_info\")\n\n    return {\n      ...token,\n      accessToken: this.crypt(accessToken, this.cipher(key, iv), IN, OUT),\n      refreshToken: this.crypt(refreshToken, this.cipher(key, iv), IN, OUT),\n      keyFileName,\n      algorithm: ALGORITHM,\n      iv\n    }\n  }\n\n  /**\n   * Decrypt freee token\n   *\n   * @param {Object} token\n   * @param {string} token.accessToken\n   * @param {string} token.refreshToken\n   * @param {string} token.keyFileName\n   * @param {string} token.algorithm\n   * @param {Buffer} token.iv\n   *\n   * @return {Promise<Object>} - decrypted freee token object\n   */\n  async decrypt(\n    token: FreeeTokenWithCryptInfo\n  ): Promise<FreeeTokenWithCryptInfo> {\n    const { accessToken, refreshToken, keyFileName, algorithm, iv } = token\n    const key = await this.getKey(keyFileName)\n    console.log(\"FreeeCryptor_decrypt_getKey\")\n    // console.log(accessToken)\n    return {\n      ...token,\n      accessToken: this.crypt(\n        accessToken,\n        this.decipher(algorithm, key, iv),\n        OUT,\n        IN\n      ),\n      refreshToken: this.crypt(\n        refreshToken,\n        this.decipher(algorithm, key, iv),\n        OUT,\n        IN\n      )\n    }\n  }\n\n  private cipher(cryptoKey: any, iv: any): Cipher {\n    return crypto.createCipheriv(ALGORITHM, cryptoKey, iv)\n  }\n\n  private decipher(algorithm: string, cryptoKey: any, iv: any): Decipher {\n    return crypto.createDecipheriv(algorithm, cryptoKey, iv)\n  }\n\n  private async getKey(keyFileName: string) {\n    console.log({keyFileName: keyFileName})\n    console.log({keyCache: this.keyCache[keyFileName]})\n    if (this.keyCache[keyFileName]) {\n      console.log(\"1------------uuuuuuu\")\n      return this.keyCache[keyFileName]\n    }\n\n    try {\n      return await this.get(keyFileName)\n    } catch (error) {\n      console.info('No key file for:', keyFileName)\n      await this.create(keyFileName)\n      return await this.get(keyFileName)\n    }\n  }\n\n  private crypt(\n    targetStr: any,\n    algorithm: Cipher | Decipher,\n    inputEncoding: any,\n    outputEncoding: any\n  ) {\n    console.log({inputEncoding:inputEncoding, outputEncoding: outputEncoding})\n    let result: any = algorithm.update(targetStr, inputEncoding, outputEncoding)\n    console.log(\"FreeeCryptor_crypt_update:\", result)\n    result += algorithm.final(outputEncoding)\n    console.log(\"FreeeCryptor_crypt_final:\", result)\n    return result\n  }\n\n  private async create(keyFileName: string) {\n    const encryptionKey = crypto.randomBytes(32)\n    const keyFile = this.bucket.file(keyFileName)\n    await keyFile.save(encryptionKey)\n    console.log('New crypto key is successfully created for:', keyFileName)\n  }\n\n  private async get(keyFileName: string) {\n    const response = await this.bucket.file(keyFileName).download()\n    this.keyCache[keyFileName] = response[0]\n    console.log('Crypto key is retrieved from storage for:', keyFileName)\n    return response[0]\n  }\n}\n\nexport default FreeeCryptor\n","import * as admin from 'firebase-admin'\nimport { FreeeToken } from '../const/types'\nimport FreeeCryptor, { FreeeTokenWithCryptInfo } from './freee-cryptor'\n\nconst MARGIN_OF_EXPIRES_SECONDS = 300\n\nexport class TokenManager {\n  private admin: admin.app.App\n  private oauth2: any // Can not use typescript version due to mismatch with freee oauth\n  private cryptor: FreeeCryptor | null\n  private tokenCache: { [key: string]: FreeeTokenWithCryptInfo }\n\n  constructor(admin: admin.app.App, oauth2: any, cryptor: FreeeCryptor | null) {\n    this.admin = admin\n    this.oauth2 = oauth2\n    this.cryptor = cryptor\n    this.tokenCache = {}\n    console.log({constructor_tokenCache: this.tokenCache})\n  }\n\n  /**\n   * Get token with handling refresh token\n   */\n  async get(userId: string): Promise<string> {\n    console.log({get_tokenCache: this.tokenCache})\n    let freeeToken: any;\n\n    try {\n      console.log(`TokenManager_get_start:`, {userId: userId})\n      freeeToken = await this.getTokenFromFirebase(userId)\n    } catch (error) {\n      throw error\n    }\n\n    if (this.tokenExpired(freeeToken)) {\n      console.log(`accessToken has been expired for user:`, userId)\n\n      try {\n        return await this.refreshToken(freeeToken, userId)\n      } catch (error) {\n        if (error.output && error.output.statusCode === 401) {\n          console.log('Token is already refreshed in other instance:', error)\n\n          const newToken = await this.getTokenFromFirebase(userId, true)\n          if (this.tokenExpired(newToken)) {\n            console.error('Can not get available token:', error)\n            throw error\n          }\n          return newToken.accessToken\n        } else {\n          throw error\n        }\n      }\n    } else {\n      return freeeToken.accessToken\n    }\n  }\n\n  /**\n   * Get token with handling refresh token\n   */\n  async save(\n    userId: string,\n    email: string,\n    freeeToken: FreeeToken\n  ): Promise<void> {\n    // freeeToken.expiresIn = 180\n    console.log({freeeToken: freeeToken})\n    const token = await this.encrypt(freeeToken)\n    console.log(\"TokenManager_save\")\n    // Save freee token to firestore\n    await this.admin\n      .firestore()\n      .doc(`/freeeTokens/${userId}`)\n      .set({\n        ...token,\n        email\n      })\n  }\n\n  async createCryptoKey(date: Date): Promise<void> {\n    if (this.cryptor) {\n      await this.cryptor.createCryptoKey(date)\n    }\n  }\n\n  private async refreshToken(\n    freeeToken: FreeeTokenWithCryptInfo,\n    userId: string\n  ) {\n    console.log(\"1----------------refreshToken\")\n    // refresh\n    const tokenObject = {\n      access_token: freeeToken.accessToken,\n      refresh_token: freeeToken.refreshToken,\n      expires_in: freeeToken.expiresIn\n    }\n    const accessToken = this.oauth2.accessToken.create(tokenObject)\n    const newToken = await accessToken.refresh()\n\n    // encrypt and cache\n    const token = (await this.encrypt({\n      accessToken: newToken.token.access_token,\n      refreshToken: newToken.token.refresh_token,\n      expiresIn: newToken.token.expires_in,\n      createdAt: newToken.token.created_at\n    })) as FreeeTokenWithCryptInfo\n    this.tokenCache[userId] = token\n\n    // save token to firestore\n    await this.admin\n      .firestore()\n      .doc(`/freeeTokens/${userId}`)\n      .set({ ...token }, { merge: true })\n\n    console.log('accessToken is successfully refreshed for user:', userId)\n\n    return newToken.token.access_token\n  }\n\n  private tokenExpired(freeeToken: FreeeTokenWithCryptInfo) {\n    const expiredSeconds =\n      freeeToken.createdAt + freeeToken.expiresIn - MARGIN_OF_EXPIRES_SECONDS\n    const nowInSeconds = new Date().getTime() / 1000\n    const shouldRefresh = nowInSeconds >= expiredSeconds\n    return shouldRefresh\n  }\n\n  private async getTokenFromFirebase(userId: string, fromFirestore?: boolean) {\n    if (!fromFirestore) {\n      console.log(`TokenManager_getTokenFromFirebase_fromFirestore:`, {fromFirestore: fromFirestore})\n      const cachedToken = this.tokenCache[userId]\n      if (cachedToken) {\n        console.log(\"TokenManager_getTokenFromFirebase_cachedToken:\", cachedToken)\n        return await this.decrypt(cachedToken)\n      }\n    }\n\n    const snap = await this.admin\n      .firestore()\n      .doc(`/freeeTokens/${userId}`)\n      .get()\n    const token = snap.data() as FreeeTokenWithCryptInfo\n    this.tokenCache[userId] = token\n\n    console.log('firebase token:', token)\n    console.log('Token is retrieved from firestore for user:', userId)\n\n    return await this.decrypt(token)\n  }\n\n  private async encrypt(freeeToken: FreeeToken) {\n    return this.cryptor ? await this.cryptor.encrypt(freeeToken) : freeeToken\n  }\n\n  private async decrypt(freeeToken: FreeeTokenWithCryptInfo) {\n    if (this.cryptor) {\n      console.log(\"TokenManager_decrypt_have_cryptor\")\n      return await this.cryptor.decrypt(freeeToken)\n    } else {\n      console.log(\"TokenManager_decrypt_return_freeeToken\")\n      return freeeToken\n    }\n  }\n}\n","module.exports = require(\"axios\");","module.exports = require(\"crypto\");","module.exports = require(\"date-fns\");","module.exports = require(\"firebase-admin\");","module.exports = require(\"firebase-functions\");","module.exports = require(\"form-data\");","module.exports = require(\"simple-oauth2\");"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClFA;AAEA;;;;;;;;;;;;;;;ACCA;AAEA;AAIA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7FA;;;;;;;;;;;;;;;ACDA;AAGA;AAgBA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AA/KA;;;;;;;;;;;;;;;ACPA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AAEA;AACA;AAOA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;ACzGA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA/BA;;;;;;;;;;;;;;;ACzGA;AAGA;AAEA;AACA;AACA;AACA;AAQA;AAIA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAQA;AAEA;;;;;;;;;;;AAWA;AACA;AAGA;AACA;AACA;AACA;AACA;AAeA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;ACpJA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AA9JA;;;;;;;;;;;;ACNA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}